
- system start up:
	- there are three component which we need to start up the system: bootloader, kernel, init process 
	- bootloader:
		- it is very hardware dependent 
		- the job is to initalize the hardware and start up the kernel
	- kernel:
		- at the begining run hardware dependent code which is responsible for initializing the hardware and then would call kernel_startup
		- kernel_startup:
			- high level initalizaion, mount rootfs, start init process 

- linux kernel:
	- kernel lives in kernel space and can access harware and io directly 
	- user space is where user code is excuted, it has less privilge and communicate with the kernel using system call 
	- at any time point the kernel is in one of three state
		- user space executing user code
		- kernel space in process context in bahalf of a process
		- kernel space in interrupt context 
	- kernel code has no access to the c library and has no memory proctection 
- user space:
	- the code which runs in a low provolige mode
	- it is linked into glibc 

- glibc:
	- every user applictioon in the kernel is linked into glibc 
	- glibc would implement the system call which is needed to access the kernel from the user land
	 - 
- kernel:
	- resource manager(CPU time, memory, scheduler )
	- abstraction layer between user application and the hardware

- monolthic kernel:
	- the kernel is executed as one process and the communication with the user space is achieved using system call

- mikro kernel:
	- the kernel is divided to many process which would communicate with each other using IPC 

- user space vs kernel space:
	- normally the process is in user space
	- switching from user space to kernel space happens in 2 cases:
		- system call
		- interrupt

- preemtive:
	- in user space process can interrupt another process if it has a higher priority
	- in kernel land only interrupt can interrupt the process

- priority:
	- policy is the bahviour of the scheduler which decides what process should run and for how long
	- the process could be I/O boundary which includes alot of waiting or process bound which mean the process execute code most of the time 
	- priority value:
		- nice priority which is the value from -20 to 19 
		- real time priority from 0  to 99
		- real time process has more priority than other process which are not real time 

- time slice: 
	- how lond should the process run too long then the system is no more interactive while too short then the system is slow because the overhead including chaning the context
	- we assign a proporition of the processor time for each process depending on the load of the system and the weight of each process scheduler make sure that if a process used less than what was assigned to it, it preemt the other process when it is needed

-fair scheduler:
	- each process receive 1/n of the process time where n in the number of the process on the system
	- we pick the task with the highest waiting time in the running queue 
	- the update of the process happen by timer interrupt

- system call:
	- user application would call a system call in the c library
	- in c library software interrupt would be made to change to the kernel mode
	- in kernel a function related to the system call would be executed

- threads: 
	- visual address space
	- every user space thread has two stacks one in user space and another one in Â´the kernel space
	- for every thread in the kernel space there is a task_struct to represent the thread
	- VAS of the process consist of text, data, heap, library and stack  

- task_struct:
	- it has all the information we need to represent a thread
	- it is chained in a linked list called task list 
	- to get the task_struct in the kernel code we use current marco which yield a pointer to the task_struct 
	- current is only valid when we run in process context
	-


- interrupt:
	- enable the hardware to signal the processor
	- processor would interrupt the executing context and notify the kernel that interrupt has happened, OS would execute ISR in response to the interrupt which runs in interrupt context meaning it cannot sleep while executing the interrupt
	- ISR would run while all other interrupt are enabled except his own interrupt line

- timer:
	- relative timer is to say something would run in 5 seconds in the future, while absolute time is to say something would run at 5 am
	- kernel knows the tick rate so he knows the time between every tick as it is nothing rather than 1/ticks second
	- HZ is the number of tickes per second  
	- jiffies is the amount of times has passed since the system has booted 
	- if u want to compare any time u should convert then to signed value and start to compare the values
		- ex: time_before(a,b) int(a) -int(b) < 0
		- it depends on the fact that when overflow in signed variable happens it start couting from the highest negatvie to the lowest negative
		- 0 1 2 3 ..244 255 -255 -244 ..3 2 1 0
	- sytem timers:
		- hardware would issue an interrupt at fixed freqency 
		- timer handler would be invoked in response to this interrupt and would update system timer 

	- dynamic timer:
		- it is a way to schedule a function to run in the future at a specific time point

- memory:
	- KiB and KB:
		- as computer is based on binary system KiB is the suitable meachanism 
		- KiB = 2^10 which is 1024
		- KB = 10^3 which is 1000
	-  virtual and physical memory:
		- page frame : physical memory
		- page : virtual memory

- page table:
	- for each process the kernel create a table which maps the virtual address to physical address 
	- the table exists in the kernel so a process can access only memory which the kernel has allowed

- LKM frame work:
	- it is a way to enable us to change a part of the kernel without rebuilding the whole system 
	- compile a piece of code outside the kernel source code 
	- if u build a module and insert it after u build the kernel we call it out of tree code
	- to build a module:
		- source file
		- header file
		- make file
		- make
	- the module would be built and .ko file would be generated then u can install it using insmod command 

- LKM:
	- module has entry point with is given by the function module_init()
	- u insert the module using the command insmod and the path to the module
	- rmmod to delete the module
	- in both cases u need root user to achieve it 

- LKM make file:
	- the name of the module which u want to build is giving using:
		obj-m +=name_of_module.o
	- rule:
		make -C "kernel source code" M=$(PWD) modules 

- printk:
	- it write to dmesg which is a ring buffer



- VAS:
	- every file would be linked into glibc as default
	- the upper part of the VAS is always the kernel and it is address started from the PAGE_OFFSET 
	- lowmem of the kernel where the memory is directed mapped to the VAS with the max size of 768 MB
	- to change from physical to logical address
		PA = kVA - Page_offset

reference counting:
	- it is a way to keep track of the c structure
	- by embedded koject in any structure u can use reference counting

- kobject:
	- struct kobject { const char* k_name; struct kref kref; struct list_head entry; struct kobject* parent; struct kset* kset; struct kobj_type * ktype; struct sysfs_dirent * sd; };
	- k_name: the name which is used by sysfs subsystem
	- kref: using in reference managment
	- entry: groups kobjects in list
	- kset: grouping the object in set
	- parent: point to the parent
	- ktype: information about the data structure in which the object is embedded, of greatest importance is the destructore 

- kset: struct kset {struct kobj_type * ktype; struct list_head list; struct kobject kobj; struct kset_uevent_ops * uevent_ops; };